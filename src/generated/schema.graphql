### This file was generated by Nexus Schema
### Do not make changes to this file directly


input AccountWhereInput {
  AND: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  accessToken: StringNullableFilter
  accessTokenExpires: DateTimeNullableFilter
  compoundId: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  providerAccountId: StringFilter
  providerId: StringFilter
  providerType: StringFilter
  refreshToken: StringNullableFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

type AffectedRowsOutput {
  count: Int!
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Category {
  color: String!
  createdAt: DateTime!
  id: String!
  label: String!
  notes(after: NoteWhereUniqueInput, before: NoteWhereUniqueInput, first: Int, last: Int): [Note!]!
  primary: Boolean!
  userId: Int!
}

input CategoryCreateInput {
  color: String!
  createdAt: DateTime
  id: String
  label: String!
  notes: NoteCreateNestedManyWithoutCategoryInput
  primary: Boolean!
  user: UserCreateNestedOneWithoutCategoriesInput!
}

input CategoryCreateManyUserInput {
  color: String!
  createdAt: DateTime
  id: String
  label: String!
  primary: Boolean!
}

input CategoryCreateManyUserInputEnvelope {
  data: [CategoryCreateManyUserInput!]
  skipDuplicates: Boolean
}

input CategoryCreateNestedManyWithoutUserInput {
  connect: [CategoryWhereUniqueInput!]
  connectOrCreate: [CategoryCreateOrConnectWithoutUserInput!]
  create: [CategoryCreateWithoutUserInput!]
  createMany: CategoryCreateManyUserInputEnvelope
}

input CategoryCreateNestedOneWithoutNotesInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutNotesInput
  create: CategoryCreateWithoutNotesInput
}

input CategoryCreateOrConnectWithoutNotesInput {
  create: CategoryCreateWithoutNotesInput!
  where: CategoryWhereUniqueInput!
}

input CategoryCreateOrConnectWithoutUserInput {
  create: CategoryCreateWithoutUserInput!
  where: CategoryWhereUniqueInput!
}

input CategoryCreateWithoutNotesInput {
  color: String!
  createdAt: DateTime
  id: String
  label: String!
  primary: Boolean!
  user: UserCreateNestedOneWithoutCategoriesInput!
}

input CategoryCreateWithoutUserInput {
  color: String!
  createdAt: DateTime
  id: String
  label: String!
  notes: NoteCreateNestedManyWithoutCategoryInput
  primary: Boolean!
}

input CategoryListRelationFilter {
  every: CategoryWhereInput
  none: CategoryWhereInput
  some: CategoryWhereInput
}

input CategoryScalarWhereInput {
  AND: [CategoryScalarWhereInput!]
  NOT: [CategoryScalarWhereInput!]
  OR: [CategoryScalarWhereInput!]
  color: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  label: StringFilter
  primary: BoolFilter
  userId: IntFilter
}

input CategoryUpdateInput {
  color: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  label: StringFieldUpdateOperationsInput
  notes: NoteUpdateManyWithoutCategoryInput
  primary: BoolFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutCategoriesInput
}

input CategoryUpdateManyMutationInput {
  color: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  label: StringFieldUpdateOperationsInput
  primary: BoolFieldUpdateOperationsInput
}

input CategoryUpdateManyWithWhereWithoutUserInput {
  data: CategoryUpdateManyMutationInput!
  where: CategoryScalarWhereInput!
}

input CategoryUpdateManyWithoutUserInput {
  connect: [CategoryWhereUniqueInput!]
  connectOrCreate: [CategoryCreateOrConnectWithoutUserInput!]
  create: [CategoryCreateWithoutUserInput!]
  createMany: CategoryCreateManyUserInputEnvelope
  delete: [CategoryWhereUniqueInput!]
  deleteMany: [CategoryScalarWhereInput!]
  disconnect: [CategoryWhereUniqueInput!]
  set: [CategoryWhereUniqueInput!]
  update: [CategoryUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [CategoryUpdateManyWithWhereWithoutUserInput!]
  upsert: [CategoryUpsertWithWhereUniqueWithoutUserInput!]
}

input CategoryUpdateOneRequiredWithoutNotesInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutNotesInput
  create: CategoryCreateWithoutNotesInput
  update: CategoryUpdateWithoutNotesInput
  upsert: CategoryUpsertWithoutNotesInput
}

input CategoryUpdateWithWhereUniqueWithoutUserInput {
  data: CategoryUpdateWithoutUserInput!
  where: CategoryWhereUniqueInput!
}

input CategoryUpdateWithoutNotesInput {
  color: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  label: StringFieldUpdateOperationsInput
  primary: BoolFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutCategoriesInput
}

input CategoryUpdateWithoutUserInput {
  color: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  label: StringFieldUpdateOperationsInput
  notes: NoteUpdateManyWithoutCategoryInput
  primary: BoolFieldUpdateOperationsInput
}

input CategoryUpsertWithWhereUniqueWithoutUserInput {
  create: CategoryCreateWithoutUserInput!
  update: CategoryUpdateWithoutUserInput!
  where: CategoryWhereUniqueInput!
}

input CategoryUpsertWithoutNotesInput {
  create: CategoryCreateWithoutNotesInput!
  update: CategoryUpdateWithoutNotesInput!
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  color: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  label: StringFilter
  notes: NoteListRelationFilter
  primary: BoolFilter
  user: UserWhereInput
  userId: IntFilter
}

input CategoryWhereUniqueInput {
  id: String
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type Mutation {
  createOneCategory(data: CategoryCreateInput!): Category!
  createOneNote(data: NoteCreateInput!): Note!
  createOneUser(data: UserCreateInput!): User!
  deleteManyAccount(where: AccountWhereInput): AffectedRowsOutput!
  deleteManyCategory(where: CategoryWhereInput): AffectedRowsOutput!
  deleteManyNote(where: NoteWhereInput): AffectedRowsOutput!
  deleteManySession(where: SessionWhereInput): AffectedRowsOutput!
  deleteOneCategory(id: String!, userId: Int!): Mutation
  deleteOneNote(where: NoteWhereUniqueInput!): Note
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyNote(data: NoteUpdateManyMutationInput!, where: NoteWhereInput): AffectedRowsOutput!
  updateOneCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateOneNote(data: NoteUpdateInput!, where: NoteWhereUniqueInput!): Note
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Note {
  category: Category!
  categoryId: String!
  content: String
  createdAt: DateTime!
  id: String!
  title: String!
  updatedAt: DateTime!
}

input NoteCreateInput {
  category: CategoryCreateNestedOneWithoutNotesInput!
  content: String
  createdAt: DateTime
  id: String
  title: String!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutNotesInput!
}

input NoteCreateManyCategoryInput {
  content: String
  createdAt: DateTime
  id: String
  title: String!
  updatedAt: DateTime
  userId: Int!
}

input NoteCreateManyCategoryInputEnvelope {
  data: [NoteCreateManyCategoryInput!]
  skipDuplicates: Boolean
}

input NoteCreateManyUserInput {
  categoryId: String!
  content: String
  createdAt: DateTime
  id: String
  title: String!
  updatedAt: DateTime
}

input NoteCreateManyUserInputEnvelope {
  data: [NoteCreateManyUserInput!]
  skipDuplicates: Boolean
}

input NoteCreateNestedManyWithoutCategoryInput {
  connect: [NoteWhereUniqueInput!]
  connectOrCreate: [NoteCreateOrConnectWithoutCategoryInput!]
  create: [NoteCreateWithoutCategoryInput!]
  createMany: NoteCreateManyCategoryInputEnvelope
}

input NoteCreateNestedManyWithoutUserInput {
  connect: [NoteWhereUniqueInput!]
  connectOrCreate: [NoteCreateOrConnectWithoutUserInput!]
  create: [NoteCreateWithoutUserInput!]
  createMany: NoteCreateManyUserInputEnvelope
}

input NoteCreateOrConnectWithoutCategoryInput {
  create: NoteCreateWithoutCategoryInput!
  where: NoteWhereUniqueInput!
}

input NoteCreateOrConnectWithoutUserInput {
  create: NoteCreateWithoutUserInput!
  where: NoteWhereUniqueInput!
}

input NoteCreateWithoutCategoryInput {
  content: String
  createdAt: DateTime
  id: String
  title: String!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutNotesInput!
}

input NoteCreateWithoutUserInput {
  category: CategoryCreateNestedOneWithoutNotesInput!
  content: String
  createdAt: DateTime
  id: String
  title: String!
  updatedAt: DateTime
}

input NoteListRelationFilter {
  every: NoteWhereInput
  none: NoteWhereInput
  some: NoteWhereInput
}

input NoteScalarWhereInput {
  AND: [NoteScalarWhereInput!]
  NOT: [NoteScalarWhereInput!]
  OR: [NoteScalarWhereInput!]
  categoryId: StringFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input NoteUpdateInput {
  category: CategoryUpdateOneRequiredWithoutNotesInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutNotesInput
}

input NoteUpdateManyMutationInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input NoteUpdateManyWithWhereWithoutCategoryInput {
  data: NoteUpdateManyMutationInput!
  where: NoteScalarWhereInput!
}

input NoteUpdateManyWithWhereWithoutUserInput {
  data: NoteUpdateManyMutationInput!
  where: NoteScalarWhereInput!
}

input NoteUpdateManyWithoutCategoryInput {
  connect: [NoteWhereUniqueInput!]
  connectOrCreate: [NoteCreateOrConnectWithoutCategoryInput!]
  create: [NoteCreateWithoutCategoryInput!]
  createMany: NoteCreateManyCategoryInputEnvelope
  delete: [NoteWhereUniqueInput!]
  deleteMany: [NoteScalarWhereInput!]
  disconnect: [NoteWhereUniqueInput!]
  set: [NoteWhereUniqueInput!]
  update: [NoteUpdateWithWhereUniqueWithoutCategoryInput!]
  updateMany: [NoteUpdateManyWithWhereWithoutCategoryInput!]
  upsert: [NoteUpsertWithWhereUniqueWithoutCategoryInput!]
}

input NoteUpdateManyWithoutUserInput {
  connect: [NoteWhereUniqueInput!]
  connectOrCreate: [NoteCreateOrConnectWithoutUserInput!]
  create: [NoteCreateWithoutUserInput!]
  createMany: NoteCreateManyUserInputEnvelope
  delete: [NoteWhereUniqueInput!]
  deleteMany: [NoteScalarWhereInput!]
  disconnect: [NoteWhereUniqueInput!]
  set: [NoteWhereUniqueInput!]
  update: [NoteUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [NoteUpdateManyWithWhereWithoutUserInput!]
  upsert: [NoteUpsertWithWhereUniqueWithoutUserInput!]
}

input NoteUpdateWithWhereUniqueWithoutCategoryInput {
  data: NoteUpdateWithoutCategoryInput!
  where: NoteWhereUniqueInput!
}

input NoteUpdateWithWhereUniqueWithoutUserInput {
  data: NoteUpdateWithoutUserInput!
  where: NoteWhereUniqueInput!
}

input NoteUpdateWithoutCategoryInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutNotesInput
}

input NoteUpdateWithoutUserInput {
  category: CategoryUpdateOneRequiredWithoutNotesInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input NoteUpsertWithWhereUniqueWithoutCategoryInput {
  create: NoteCreateWithoutCategoryInput!
  update: NoteUpdateWithoutCategoryInput!
  where: NoteWhereUniqueInput!
}

input NoteUpsertWithWhereUniqueWithoutUserInput {
  create: NoteCreateWithoutUserInput!
  update: NoteUpdateWithoutUserInput!
  where: NoteWhereUniqueInput!
}

input NoteWhereInput {
  AND: [NoteWhereInput!]
  NOT: [NoteWhereInput!]
  OR: [NoteWhereInput!]
  category: CategoryWhereInput
  categoryId: StringFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: IntFilter
}

input NoteWhereUniqueInput {
  id: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  categories(after: CategoryWhereUniqueInput, before: CategoryWhereUniqueInput, first: Int, last: Int, where: CategoryWhereInput): [Category!]!
  note(id: String!, userId: Int!): Note
  notes(after: NoteWhereUniqueInput, before: NoteWhereUniqueInput, first: Int, last: Int): [Note!]!
  user(where: UserWhereUniqueInput!): User
}

enum QueryMode {
  default
  insensitive
}

input SessionWhereInput {
  AND: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  accessToken: StringFilter
  createdAt: DateTimeFilter
  expires: DateTimeFilter
  id: IntFilter
  sessionToken: StringFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type User {
  categories(after: CategoryWhereUniqueInput, before: CategoryWhereUniqueInput, first: Int, last: Int): [Category!]!
  createdAt: DateTime!
  email: String
  id: Int!
  image: String
  name: String
  notes(after: NoteWhereUniqueInput, before: NoteWhereUniqueInput, first: Int, last: Int): [Note!]!
  updatedAt: DateTime!
}

input UserCreateInput {
  categories: CategoryCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String
  emailVerified: DateTime
  image: String
  name: String
  notes: NoteCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateNestedOneWithoutCategoriesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCategoriesInput
  create: UserCreateWithoutCategoriesInput
}

input UserCreateNestedOneWithoutNotesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutNotesInput
  create: UserCreateWithoutNotesInput
}

input UserCreateOrConnectWithoutCategoriesInput {
  create: UserCreateWithoutCategoriesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutNotesInput {
  create: UserCreateWithoutNotesInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutCategoriesInput {
  createdAt: DateTime
  email: String
  emailVerified: DateTime
  image: String
  name: String
  notes: NoteCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateWithoutNotesInput {
  categories: CategoryCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String
  emailVerified: DateTime
  image: String
  name: String
  updatedAt: DateTime
}

input UserUpdateInput {
  categories: CategoryUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  notes: NoteUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutCategoriesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCategoriesInput
  create: UserCreateWithoutCategoriesInput
  update: UserUpdateWithoutCategoriesInput
  upsert: UserUpsertWithoutCategoriesInput
}

input UserUpdateOneRequiredWithoutNotesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutNotesInput
  create: UserCreateWithoutNotesInput
  update: UserUpdateWithoutNotesInput
  upsert: UserUpsertWithoutNotesInput
}

input UserUpdateWithoutCategoriesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  notes: NoteUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutNotesInput {
  categories: CategoryUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutCategoriesInput {
  create: UserCreateWithoutCategoriesInput!
  update: UserUpdateWithoutCategoriesInput!
}

input UserUpsertWithoutNotesInput {
  create: UserCreateWithoutNotesInput!
  update: UserUpdateWithoutNotesInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  categories: CategoryListRelationFilter
  createdAt: DateTimeFilter
  email: StringNullableFilter
  emailVerified: DateTimeNullableFilter
  id: IntFilter
  image: StringNullableFilter
  name: StringNullableFilter
  notes: NoteListRelationFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
